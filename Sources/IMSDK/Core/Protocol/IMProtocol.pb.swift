// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: IMProtocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// IMProtocol.proto
// 自定义 IM 协议定义（使用 Protocol Buffers）
// 编译命令：protoc --swift_out=. IMProtocol.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 命令类型
enum Im_Protocol_CommandType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case cmdUnknown // = 0

  /// 连接相关（1-99）
  case cmdConnectReq // = 1

  /// 连接响应
  case cmdConnectRsp // = 2

  /// 断开请求
  case cmdDisconnectReq // = 3

  /// 断开响应
  case cmdDisconnectRsp // = 4

  /// 心跳请求
  case cmdHeartbeatReq // = 5

  /// 心跳响应
  case cmdHeartbeatRsp // = 6

  /// 认证相关（100-199）
  case cmdAuthReq // = 100

  /// 认证响应
  case cmdAuthRsp // = 101

  /// 重新认证请求
  case cmdReauthReq // = 102

  /// 重新认证响应
  case cmdReauthRsp // = 103

  /// 踢出通知
  case cmdKickOut // = 104

  /// 消息相关（200-299）
  case cmdSendMsgReq // = 200

  /// 发送消息响应
  case cmdSendMsgRsp // = 201

  /// 推送消息（服务器 → 客户端）
  case cmdPushMsg // = 202

  /// 消息 ACK
  case cmdMsgAck // = 203

  /// 批量消息
  case cmdBatchMsg // = 204

  /// 撤回消息请求
  case cmdRevokeMsgReq // = 205

  /// 撤回消息响应
  case cmdRevokeMsgRsp // = 206

  /// 撤回消息推送
  case cmdRevokeMsgPush // = 207

  /// 同步相关（300-399）
  case cmdSyncReq // = 300

  /// 增量同步响应
  case cmdSyncRsp // = 301

  /// 同步完成通知
  case cmdSyncFinished // = 302

  /// 在线状态（400-499）
  case cmdOnlineStatusReq // = 400

  /// 在线状态响应
  case cmdOnlineStatusRsp // = 401

  /// 状态变化推送
  case cmdStatusChangePush // = 402

  /// 已读回执（500-599）
  case cmdReadReceiptReq // = 500

  /// 已读回执响应
  case cmdReadReceiptRsp // = 501

  /// 已读回执推送
  case cmdReadReceiptPush // = 502

  /// 输入状态（600-699）
  case cmdTypingStatusReq // = 600

  /// 输入状态推送
  case cmdTypingStatusPush // = 601
  case UNRECOGNIZED(Int)

  init() {
    self = .cmdUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cmdUnknown
    case 1: self = .cmdConnectReq
    case 2: self = .cmdConnectRsp
    case 3: self = .cmdDisconnectReq
    case 4: self = .cmdDisconnectRsp
    case 5: self = .cmdHeartbeatReq
    case 6: self = .cmdHeartbeatRsp
    case 100: self = .cmdAuthReq
    case 101: self = .cmdAuthRsp
    case 102: self = .cmdReauthReq
    case 103: self = .cmdReauthRsp
    case 104: self = .cmdKickOut
    case 200: self = .cmdSendMsgReq
    case 201: self = .cmdSendMsgRsp
    case 202: self = .cmdPushMsg
    case 203: self = .cmdMsgAck
    case 204: self = .cmdBatchMsg
    case 205: self = .cmdRevokeMsgReq
    case 206: self = .cmdRevokeMsgRsp
    case 207: self = .cmdRevokeMsgPush
    case 300: self = .cmdSyncReq
    case 301: self = .cmdSyncRsp
    case 302: self = .cmdSyncFinished
    case 400: self = .cmdOnlineStatusReq
    case 401: self = .cmdOnlineStatusRsp
    case 402: self = .cmdStatusChangePush
    case 500: self = .cmdReadReceiptReq
    case 501: self = .cmdReadReceiptRsp
    case 502: self = .cmdReadReceiptPush
    case 600: self = .cmdTypingStatusReq
    case 601: self = .cmdTypingStatusPush
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cmdUnknown: return 0
    case .cmdConnectReq: return 1
    case .cmdConnectRsp: return 2
    case .cmdDisconnectReq: return 3
    case .cmdDisconnectRsp: return 4
    case .cmdHeartbeatReq: return 5
    case .cmdHeartbeatRsp: return 6
    case .cmdAuthReq: return 100
    case .cmdAuthRsp: return 101
    case .cmdReauthReq: return 102
    case .cmdReauthRsp: return 103
    case .cmdKickOut: return 104
    case .cmdSendMsgReq: return 200
    case .cmdSendMsgRsp: return 201
    case .cmdPushMsg: return 202
    case .cmdMsgAck: return 203
    case .cmdBatchMsg: return 204
    case .cmdRevokeMsgReq: return 205
    case .cmdRevokeMsgRsp: return 206
    case .cmdRevokeMsgPush: return 207
    case .cmdSyncReq: return 300
    case .cmdSyncRsp: return 301
    case .cmdSyncFinished: return 302
    case .cmdOnlineStatusReq: return 400
    case .cmdOnlineStatusRsp: return 401
    case .cmdStatusChangePush: return 402
    case .cmdReadReceiptReq: return 500
    case .cmdReadReceiptRsp: return 501
    case .cmdReadReceiptPush: return 502
    case .cmdTypingStatusReq: return 600
    case .cmdTypingStatusPush: return 601
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Im_Protocol_CommandType] = [
    .cmdUnknown,
    .cmdConnectReq,
    .cmdConnectRsp,
    .cmdDisconnectReq,
    .cmdDisconnectRsp,
    .cmdHeartbeatReq,
    .cmdHeartbeatRsp,
    .cmdAuthReq,
    .cmdAuthRsp,
    .cmdReauthReq,
    .cmdReauthRsp,
    .cmdKickOut,
    .cmdSendMsgReq,
    .cmdSendMsgRsp,
    .cmdPushMsg,
    .cmdMsgAck,
    .cmdBatchMsg,
    .cmdRevokeMsgReq,
    .cmdRevokeMsgRsp,
    .cmdRevokeMsgPush,
    .cmdSyncReq,
    .cmdSyncRsp,
    .cmdSyncFinished,
    .cmdOnlineStatusReq,
    .cmdOnlineStatusRsp,
    .cmdStatusChangePush,
    .cmdReadReceiptReq,
    .cmdReadReceiptRsp,
    .cmdReadReceiptPush,
    .cmdTypingStatusReq,
    .cmdTypingStatusPush,
  ]

}

/// 错误码
enum Im_Protocol_ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// 成功
  case errSuccess // = 0

  /// 未知错误
  case errUnknown // = 1

  /// 参数错误
  case errInvalidParam // = 2

  /// 认证失败
  case errAuthFailed // = 100

  /// Token 过期
  case errTokenExpired // = 101

  /// 权限不足
  case errPermissionDenied // = 102

  /// 用户不存在
  case errUserNotExist // = 103

  /// 消息过大
  case errMessageTooLarge // = 200

  /// 发送过快
  case errSendTooFast // = 201

  /// 会话不存在
  case errConversationNotExist // = 202
  case UNRECOGNIZED(Int)

  init() {
    self = .errSuccess
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errSuccess
    case 1: self = .errUnknown
    case 2: self = .errInvalidParam
    case 100: self = .errAuthFailed
    case 101: self = .errTokenExpired
    case 102: self = .errPermissionDenied
    case 103: self = .errUserNotExist
    case 200: self = .errMessageTooLarge
    case 201: self = .errSendTooFast
    case 202: self = .errConversationNotExist
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .errSuccess: return 0
    case .errUnknown: return 1
    case .errInvalidParam: return 2
    case .errAuthFailed: return 100
    case .errTokenExpired: return 101
    case .errPermissionDenied: return 102
    case .errUserNotExist: return 103
    case .errMessageTooLarge: return 200
    case .errSendTooFast: return 201
    case .errConversationNotExist: return 202
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Im_Protocol_ErrorCode] = [
    .errSuccess,
    .errUnknown,
    .errInvalidParam,
    .errAuthFailed,
    .errTokenExpired,
    .errPermissionDenied,
    .errUserNotExist,
    .errMessageTooLarge,
    .errSendTooFast,
    .errConversationNotExist,
  ]

}

/// 连接请求
struct Im_Protocol_ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端 ID
  var clientID: String = String()

  /// 平台（iOS/Android/Web）
  var platform: String = String()

  /// App 版本
  var appVersion: String = String()

  /// SDK 版本
  var sdkVersion: String = String()

  /// 设备信息
  var deviceInfo: String = String()

  /// 扩展字段
  var extra: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 连接响应
struct Im_Protocol_ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 服务器时间（毫秒）
  var serverTime: Int64 = 0

  /// 会话 ID
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 心跳请求
struct Im_Protocol_HeartbeatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端时间（毫秒）
  var clientTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 心跳响应
struct Im_Protocol_HeartbeatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 服务器时间（毫秒）
  var serverTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 认证请求
struct Im_Protocol_AuthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var token: String = String()

  var platform: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 认证响应
struct Im_Protocol_AuthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 当前最大序列号（用于增量同步）
  var maxSeq: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 踢出通知
struct Im_Protocol_KickOutNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 踢出原因（1: 其他设备登录，2: 账号异常等）
  var reason: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 发送消息请求
struct Im_Protocol_SendMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端消息 ID
  var clientMsgID: String = String()

  /// 会话 ID
  var conversationID: String = String()

  /// 发送者 ID
  var senderID: String = String()

  /// 接收者 ID（单聊）
  var receiverID: String = String()

  /// 群组 ID（群聊）
  var groupID: String = String()

  /// 消息类型
  var messageType: Int32 = 0

  /// 消息内容（JSON 字节）
  var content: Data = Data()

  /// 发送时间
  var sendTime: Int64 = 0

  var extra: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 发送消息响应
struct Im_Protocol_SendMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 服务器消息 ID
  var messageID: String = String()

  /// 消息序列号
  var seq: Int64 = 0

  /// 服务器时间
  var serverTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 推送消息
struct Im_Protocol_PushMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var clientMsgID: String = String()

  var conversationID: String = String()

  var senderID: String = String()

  var receiverID: String = String()

  var groupID: String = String()

  var messageType: Int32 = 0

  var content: Data = Data()

  var sendTime: Int64 = 0

  var serverTime: Int64 = 0

  var seq: Int64 = 0

  var extra: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 消息 ACK
struct Im_Protocol_MessageAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var seq: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 批量消息
struct Im_Protocol_BatchMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Im_Protocol_PushMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 撤回消息请求
struct Im_Protocol_RevokeMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var conversationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 撤回消息响应
struct Im_Protocol_RevokeMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 撤回消息推送
struct Im_Protocol_RevokeMessagePush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: String = String()

  var conversationID: String = String()

  var revokedBy: String = String()

  var revokedTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 增量同步请求
struct Im_Protocol_SyncRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端当前最小 seq
  var minSeq: Int64 = 0

  /// 客户端当前最大 seq
  var maxSeq: Int64 = 0

  /// 每次拉取数量
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 增量同步响应
struct Im_Protocol_SyncResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  var messages: [Im_Protocol_PushMessage] = []

  /// 服务器当前最大 seq
  var serverMaxSeq: Int64 = 0

  /// 是否还有更多消息
  var hasMore_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 已读回执请求
struct Im_Protocol_ReadReceiptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageIds: [String] = []

  var conversationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 已读回执响应
struct Im_Protocol_ReadReceiptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 已读回执推送
struct Im_Protocol_ReadReceiptPush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageIds: [String] = []

  var conversationID: String = String()

  var userID: String = String()

  var readTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 输入状态请求
struct Im_Protocol_TypingStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String = String()

  /// 0: 停止输入，1: 正在输入
  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 输入状态推送
struct Im_Protocol_TypingStatusPush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String = String()

  var userID: String = String()

  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ============================================
/// WebSocket 专用消息封装
/// ============================================
///
/// WebSocket 传输使用此通用消息格式（不使用 IMPacket header）
/// WebSocket 自带消息边界和校验，无需额外的 length 和 CRC
struct Im_Protocol_WebSocketMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 命令类型
  var command: Im_Protocol_CommandType = .cmdUnknown

  /// 序列号
  var sequence: UInt32 = 0

  /// 消息体（具体消息的 Protobuf 序列化）
  var body: Data = Data()

  /// 时间戳（毫秒）
  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "im.protocol"

extension Im_Protocol_CommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CMD_UNKNOWN\0\u{1}CMD_CONNECT_REQ\0\u{1}CMD_CONNECT_RSP\0\u{1}CMD_DISCONNECT_REQ\0\u{1}CMD_DISCONNECT_RSP\0\u{1}CMD_HEARTBEAT_REQ\0\u{1}CMD_HEARTBEAT_RSP\0\u{2}^\u{1}CMD_AUTH_REQ\0\u{1}CMD_AUTH_RSP\0\u{1}CMD_REAUTH_REQ\0\u{1}CMD_REAUTH_RSP\0\u{1}CMD_KICK_OUT\0\u{2}`\u{1}CMD_SEND_MSG_REQ\0\u{1}CMD_SEND_MSG_RSP\0\u{1}CMD_PUSH_MSG\0\u{1}CMD_MSG_ACK\0\u{1}CMD_BATCH_MSG\0\u{1}CMD_REVOKE_MSG_REQ\0\u{1}CMD_REVOKE_MSG_RSP\0\u{1}CMD_REVOKE_MSG_PUSH\0\u{2}]\u{1}CMD_SYNC_REQ\0\u{1}CMD_SYNC_RSP\0\u{1}CMD_SYNC_FINISHED\0\u{2}b\u{1}CMD_ONLINE_STATUS_REQ\0\u{1}CMD_ONLINE_STATUS_RSP\0\u{1}CMD_STATUS_CHANGE_PUSH\0\u{2}b\u{1}CMD_READ_RECEIPT_REQ\0\u{1}CMD_READ_RECEIPT_RSP\0\u{1}CMD_READ_RECEIPT_PUSH\0\u{2}b\u{1}CMD_TYPING_STATUS_REQ\0\u{1}CMD_TYPING_STATUS_PUSH\0")
}

extension Im_Protocol_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ERR_SUCCESS\0\u{1}ERR_UNKNOWN\0\u{1}ERR_INVALID_PARAM\0\u{2}b\u{1}ERR_AUTH_FAILED\0\u{1}ERR_TOKEN_EXPIRED\0\u{1}ERR_PERMISSION_DENIED\0\u{1}ERR_USER_NOT_EXIST\0\u{2}a\u{1}ERR_MESSAGE_TOO_LARGE\0\u{1}ERR_SEND_TOO_FAST\0\u{1}ERR_CONVERSATION_NOT_EXIST\0")
}

extension Im_Protocol_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}client_id\0\u{1}platform\0\u{3}app_version\0\u{3}sdk_version\0\u{3}device_info\0\u{2}\u{5}extra\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deviceInfo) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extra) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 2)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 3)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 4)
    }
    if !self.deviceInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceInfo, fieldNumber: 5)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extra, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ConnectRequest, rhs: Im_Protocol_ConnectRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs.deviceInfo != rhs.deviceInfo {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}server_time\0\u{3}session_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ConnectResponse, rhs: Im_Protocol_ConnectResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_HeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeartbeatRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}client_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientTime != 0 {
      try visitor.visitSingularInt64Field(value: self.clientTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_HeartbeatRequest, rhs: Im_Protocol_HeartbeatRequest) -> Bool {
    if lhs.clientTime != rhs.clientTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_HeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeartbeatResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_HeartbeatResponse, rhs: Im_Protocol_HeartbeatResponse) -> Bool {
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}token\0\u{1}platform\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_AuthRequest, rhs: Im_Protocol_AuthRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_AuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}max_seq\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if self.maxSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSeq, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_AuthResponse, rhs: Im_Protocol_AuthResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.maxSeq != rhs.maxSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_KickOutNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KickOutNotification"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != 0 {
      try visitor.visitSingularInt32Field(value: self.reason, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_KickOutNotification, rhs: Im_Protocol_KickOutNotification) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}client_msg_id\0\u{3}conversation_id\0\u{3}sender_id\0\u{3}receiver_id\0\u{3}group_id\0\u{3}message_type\0\u{1}content\0\u{3}send_time\0\u{2}\u{2}extra\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientMsgID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.senderID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.receiverID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.messageType) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.sendTime) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extra) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientMsgID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 3)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 4)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 5)
    }
    if self.messageType != 0 {
      try visitor.visitSingularInt32Field(value: self.messageType, fieldNumber: 6)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 7)
    }
    if self.sendTime != 0 {
      try visitor.visitSingularInt64Field(value: self.sendTime, fieldNumber: 8)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extra, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SendMessageRequest, rhs: Im_Protocol_SendMessageRequest) -> Bool {
    if lhs.clientMsgID != rhs.clientMsgID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.content != rhs.content {return false}
    if lhs.sendTime != rhs.sendTime {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}message_id\0\u{1}seq\0\u{3}server_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.seq) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 3)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 4)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SendMessageResponse, rhs: Im_Protocol_SendMessageResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_PushMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0\u{3}client_msg_id\0\u{3}conversation_id\0\u{3}sender_id\0\u{3}receiver_id\0\u{3}group_id\0\u{3}message_type\0\u{1}content\0\u{3}send_time\0\u{3}server_time\0\u{1}seq\0\u{2}\u{4}extra\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientMsgID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.senderID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.receiverID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.messageType) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.sendTime) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.seq) }()
      case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extra) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.clientMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientMsgID, fieldNumber: 2)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 3)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 4)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 5)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 6)
    }
    if self.messageType != 0 {
      try visitor.visitSingularInt32Field(value: self.messageType, fieldNumber: 7)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 8)
    }
    if self.sendTime != 0 {
      try visitor.visitSingularInt64Field(value: self.sendTime, fieldNumber: 9)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 10)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 11)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extra, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_PushMessage, rhs: Im_Protocol_PushMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.clientMsgID != rhs.clientMsgID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.content != rhs.content {return false}
    if lhs.sendTime != rhs.sendTime {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_MessageAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageAck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0\u{1}seq\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.seq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_MessageAck, rhs: Im_Protocol_MessageAck) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_BatchMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchMessages"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messages\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_BatchMessages, rhs: Im_Protocol_BatchMessages) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_RevokeMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeMessageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0\u{3}conversation_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_RevokeMessageRequest, rhs: Im_Protocol_RevokeMessageRequest) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_RevokeMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_RevokeMessageResponse, rhs: Im_Protocol_RevokeMessageResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_RevokeMessagePush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeMessagePush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0\u{3}conversation_id\0\u{3}revoked_by\0\u{3}revoked_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.revokedBy) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.revokedTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.revokedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.revokedBy, fieldNumber: 3)
    }
    if self.revokedTime != 0 {
      try visitor.visitSingularInt64Field(value: self.revokedTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_RevokeMessagePush, rhs: Im_Protocol_RevokeMessagePush) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.revokedBy != rhs.revokedBy {return false}
    if lhs.revokedTime != rhs.revokedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}min_seq\0\u{3}max_seq\0\u{1}limit\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.minSeq) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxSeq) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.minSeq, fieldNumber: 1)
    }
    if self.maxSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSeq, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SyncRequest, rhs: Im_Protocol_SyncRequest) -> Bool {
    if lhs.minSeq != rhs.minSeq {return false}
    if lhs.maxSeq != rhs.maxSeq {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{1}messages\0\u{3}server_max_seq\0\u{3}has_more\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.serverMaxSeq) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    if self.serverMaxSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.serverMaxSeq, fieldNumber: 4)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SyncResponse, rhs: Im_Protocol_SyncResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.serverMaxSeq != rhs.serverMaxSeq {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ReadReceiptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadReceiptRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_ids\0\u{3}conversation_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.messageIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messageIds, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ReadReceiptRequest, rhs: Im_Protocol_ReadReceiptRequest) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ReadReceiptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadReceiptResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ReadReceiptResponse, rhs: Im_Protocol_ReadReceiptResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ReadReceiptPush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadReceiptPush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_ids\0\u{3}conversation_id\0\u{3}user_id\0\u{3}read_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.messageIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.readTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messageIds, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if self.readTime != 0 {
      try visitor.visitSingularInt64Field(value: self.readTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ReadReceiptPush, rhs: Im_Protocol_ReadReceiptPush) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.readTime != rhs.readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_TypingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_TypingStatusRequest, rhs: Im_Protocol_TypingStatusRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_TypingStatusPush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingStatusPush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{3}user_id\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_TypingStatusPush, rhs: Im_Protocol_TypingStatusPush) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_WebSocketMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebSocketMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}sequence\0\u{1}body\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .cmdUnknown {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 2)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_WebSocketMessage, rhs: Im_Protocol_WebSocketMessage) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.body != rhs.body {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
