// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: IMProtocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// IMProtocol.proto
// 自定义 IM 协议定义（使用 Protocol Buffers）
// 编译命令：protoc --swift_out=. IMProtocol.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 命令类型
enum Im_Protocol_CommandType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case cmdUnknown // = 0

  /// 连接相关（1-99）
  case cmdConnectReq // = 1

  /// 连接响应
  case cmdConnectRsp // = 2

  /// 断开请求
  case cmdDisconnectReq // = 3

  /// 断开响应
  case cmdDisconnectRsp // = 4

  /// 心跳请求
  case cmdHeartbeatReq // = 5

  /// 心跳响应
  case cmdHeartbeatRsp // = 6

  /// 认证相关（100-199）
  case cmdAuthReq // = 100

  /// 认证响应
  case cmdAuthRsp // = 101

  /// 重新认证请求
  case cmdReauthReq // = 102

  /// 重新认证响应
  case cmdReauthRsp // = 103

  /// 踢出通知
  case cmdKickOut // = 104

  /// 消息相关（200-299）
  case cmdSendMsgReq // = 200

  /// 发送消息响应
  case cmdSendMsgRsp // = 201

  /// 推送消息（服务器 → 客户端）
  case cmdPushMsg // = 202

  /// 消息 ACK
  case cmdMsgAck // = 203

  /// 批量消息
  case cmdBatchMsg // = 204

  /// 撤回消息请求
  case cmdRevokeMsgReq // = 205

  /// 撤回消息响应
  case cmdRevokeMsgRsp // = 206

  /// 撤回消息推送
  case cmdRevokeMsgPush // = 207

  /// 同步相关（300-399）
  case cmdBatchSyncReq // = 300

  /// 批量同步响应
  case cmdBatchSyncRsp // = 301

  /// 同步完成通知
  case cmdSyncFinished // = 302

  /// 范围同步请求（补拉丢失消息）
  case cmdSyncRangeReq // = 303

  /// 范围同步响应
  case cmdSyncRangeRsp // = 304

  /// 在线状态（400-499）
  case cmdOnlineStatusReq // = 400

  /// 在线状态响应
  case cmdOnlineStatusRsp // = 401

  /// 状态变化推送
  case cmdStatusChangePush // = 402

  /// 已读回执（500-599）
  case cmdReadReceiptReq // = 500

  /// 已读回执响应
  case cmdReadReceiptRsp // = 501

  /// 已读回执推送
  case cmdReadReceiptPush // = 502

  /// 输入状态（600-699）
  case cmdTypingStatusReq // = 600

  /// 输入状态推送
  case cmdTypingStatusPush // = 601
  case UNRECOGNIZED(Int)

  init() {
    self = .cmdUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cmdUnknown
    case 1: self = .cmdConnectReq
    case 2: self = .cmdConnectRsp
    case 3: self = .cmdDisconnectReq
    case 4: self = .cmdDisconnectRsp
    case 5: self = .cmdHeartbeatReq
    case 6: self = .cmdHeartbeatRsp
    case 100: self = .cmdAuthReq
    case 101: self = .cmdAuthRsp
    case 102: self = .cmdReauthReq
    case 103: self = .cmdReauthRsp
    case 104: self = .cmdKickOut
    case 200: self = .cmdSendMsgReq
    case 201: self = .cmdSendMsgRsp
    case 202: self = .cmdPushMsg
    case 203: self = .cmdMsgAck
    case 204: self = .cmdBatchMsg
    case 205: self = .cmdRevokeMsgReq
    case 206: self = .cmdRevokeMsgRsp
    case 207: self = .cmdRevokeMsgPush
    case 300: self = .cmdBatchSyncReq
    case 301: self = .cmdBatchSyncRsp
    case 302: self = .cmdSyncFinished
    case 303: self = .cmdSyncRangeReq
    case 304: self = .cmdSyncRangeRsp
    case 400: self = .cmdOnlineStatusReq
    case 401: self = .cmdOnlineStatusRsp
    case 402: self = .cmdStatusChangePush
    case 500: self = .cmdReadReceiptReq
    case 501: self = .cmdReadReceiptRsp
    case 502: self = .cmdReadReceiptPush
    case 600: self = .cmdTypingStatusReq
    case 601: self = .cmdTypingStatusPush
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cmdUnknown: return 0
    case .cmdConnectReq: return 1
    case .cmdConnectRsp: return 2
    case .cmdDisconnectReq: return 3
    case .cmdDisconnectRsp: return 4
    case .cmdHeartbeatReq: return 5
    case .cmdHeartbeatRsp: return 6
    case .cmdAuthReq: return 100
    case .cmdAuthRsp: return 101
    case .cmdReauthReq: return 102
    case .cmdReauthRsp: return 103
    case .cmdKickOut: return 104
    case .cmdSendMsgReq: return 200
    case .cmdSendMsgRsp: return 201
    case .cmdPushMsg: return 202
    case .cmdMsgAck: return 203
    case .cmdBatchMsg: return 204
    case .cmdRevokeMsgReq: return 205
    case .cmdRevokeMsgRsp: return 206
    case .cmdRevokeMsgPush: return 207
    case .cmdBatchSyncReq: return 300
    case .cmdBatchSyncRsp: return 301
    case .cmdSyncFinished: return 302
    case .cmdSyncRangeReq: return 303
    case .cmdSyncRangeRsp: return 304
    case .cmdOnlineStatusReq: return 400
    case .cmdOnlineStatusRsp: return 401
    case .cmdStatusChangePush: return 402
    case .cmdReadReceiptReq: return 500
    case .cmdReadReceiptRsp: return 501
    case .cmdReadReceiptPush: return 502
    case .cmdTypingStatusReq: return 600
    case .cmdTypingStatusPush: return 601
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Im_Protocol_CommandType] = [
    .cmdUnknown,
    .cmdConnectReq,
    .cmdConnectRsp,
    .cmdDisconnectReq,
    .cmdDisconnectRsp,
    .cmdHeartbeatReq,
    .cmdHeartbeatRsp,
    .cmdAuthReq,
    .cmdAuthRsp,
    .cmdReauthReq,
    .cmdReauthRsp,
    .cmdKickOut,
    .cmdSendMsgReq,
    .cmdSendMsgRsp,
    .cmdPushMsg,
    .cmdMsgAck,
    .cmdBatchMsg,
    .cmdRevokeMsgReq,
    .cmdRevokeMsgRsp,
    .cmdRevokeMsgPush,
    .cmdBatchSyncReq,
    .cmdBatchSyncRsp,
    .cmdSyncFinished,
    .cmdSyncRangeReq,
    .cmdSyncRangeRsp,
    .cmdOnlineStatusReq,
    .cmdOnlineStatusRsp,
    .cmdStatusChangePush,
    .cmdReadReceiptReq,
    .cmdReadReceiptRsp,
    .cmdReadReceiptPush,
    .cmdTypingStatusReq,
    .cmdTypingStatusPush,
  ]

}

/// 错误码
enum Im_Protocol_ErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// 成功
  case errSuccess // = 0

  /// 未知错误
  case errUnknown // = 1

  /// 参数错误
  case errInvalidParam // = 2

  /// 认证失败
  case errAuthFailed // = 100

  /// Token 过期
  case errTokenExpired // = 101

  /// 权限不足
  case errPermissionDenied // = 102

  /// 用户不存在
  case errUserNotExist // = 103

  /// 消息过大
  case errMessageTooLarge // = 200

  /// 发送过快
  case errSendTooFast // = 201

  /// 会话不存在
  case errConversationNotExist // = 202
  case UNRECOGNIZED(Int)

  init() {
    self = .errSuccess
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errSuccess
    case 1: self = .errUnknown
    case 2: self = .errInvalidParam
    case 100: self = .errAuthFailed
    case 101: self = .errTokenExpired
    case 102: self = .errPermissionDenied
    case 103: self = .errUserNotExist
    case 200: self = .errMessageTooLarge
    case 201: self = .errSendTooFast
    case 202: self = .errConversationNotExist
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .errSuccess: return 0
    case .errUnknown: return 1
    case .errInvalidParam: return 2
    case .errAuthFailed: return 100
    case .errTokenExpired: return 101
    case .errPermissionDenied: return 102
    case .errUserNotExist: return 103
    case .errMessageTooLarge: return 200
    case .errSendTooFast: return 201
    case .errConversationNotExist: return 202
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Im_Protocol_ErrorCode] = [
    .errSuccess,
    .errUnknown,
    .errInvalidParam,
    .errAuthFailed,
    .errTokenExpired,
    .errPermissionDenied,
    .errUserNotExist,
    .errMessageTooLarge,
    .errSendTooFast,
    .errConversationNotExist,
  ]

}

/// 连接请求
struct Im_Protocol_ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端 ID
  var clientID: String = String()

  /// 平台（iOS/Android/Web）
  var platform: String = String()

  /// App 版本
  var appVersion: String = String()

  /// SDK 版本
  var sdkVersion: String = String()

  /// 设备信息
  var deviceInfo: String = String()

  /// 扩展字段
  var extra: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 连接响应
struct Im_Protocol_ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 服务器时间（毫秒）
  var serverTime: Int64 = 0

  /// 会话 ID
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 心跳请求
struct Im_Protocol_HeartbeatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端时间（毫秒）
  var clientTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 心跳响应
struct Im_Protocol_HeartbeatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 服务器时间（毫秒）
  var serverTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 认证请求
struct Im_Protocol_AuthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var token: String = String()

  var platform: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 认证响应
struct Im_Protocol_AuthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 当前最大序列号（用于增量同步）
  var maxSeq: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 踢出通知
struct Im_Protocol_KickOutNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 踢出原因（1: 其他设备登录，2: 账号异常等）
  var reason: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 通用消息信息（各场景复用）
struct Im_Protocol_MessageInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 服务器消息 ID（发送时为空，由服务端生成）
  var serverMsgID: String {
    get {return _storage._serverMsgID}
    set {_uniqueStorage()._serverMsgID = newValue}
  }

  /// 客户端消息 ID
  var clientMsgID: String {
    get {return _storage._clientMsgID}
    set {_uniqueStorage()._clientMsgID = newValue}
  }

  /// 会话 ID
  var conversationID: String {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  /// 发送者 ID
  var senderID: String {
    get {return _storage._senderID}
    set {_uniqueStorage()._senderID = newValue}
  }

  /// 接收者 ID（单聊）
  var receiverID: String {
    get {return _storage._receiverID}
    set {_uniqueStorage()._receiverID = newValue}
  }

  /// 群组 ID（群聊）
  var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// 消息类型
  var messageType: Int32 {
    get {return _storage._messageType}
    set {_uniqueStorage()._messageType = newValue}
  }

  /// 消息内容（JSON 字节）
  var content: Data {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// 发送时间
  var sendTime: Int64 {
    get {return _storage._sendTime}
    set {_uniqueStorage()._sendTime = newValue}
  }

  /// 服务器时间
  var serverTime: Int64 {
    get {return _storage._serverTime}
    set {_uniqueStorage()._serverTime = newValue}
  }

  /// 消息序列号（发送时为0，由服务端生成）
  var seq: Int64 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  /// 消息状态（同步时使用）
  var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// 是否已读（同步时使用）
  var isRead: Bool {
    get {return _storage._isRead}
    set {_uniqueStorage()._isRead = newValue}
  }

  /// 创建时间（客户端创建消息的时间）
  var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// 扩展字段（JSON 字符串）
  var extra: String {
    get {return _storage._extra}
    set {_uniqueStorage()._extra = newValue}
  }

  /// 已读者 ID 列表（群聊）
  var readBy: [String] {
    get {return _storage._readBy}
    set {_uniqueStorage()._readBy = newValue}
  }

  /// 读取时间（单聊）
  var readTime: Int64 {
    get {return _storage._readTime}
    set {_uniqueStorage()._readTime = newValue}
  }

  /// 是否已删除
  var isDeleted: Bool {
    get {return _storage._isDeleted}
    set {_uniqueStorage()._isDeleted = newValue}
  }

  /// 是否已撤回
  var isRevoked: Bool {
    get {return _storage._isRevoked}
    set {_uniqueStorage()._isRevoked = newValue}
  }

  /// 撤回者 ID
  var revokedBy: String {
    get {return _storage._revokedBy}
    set {_uniqueStorage()._revokedBy = newValue}
  }

  /// 撤回时间
  var revokedTime: Int64 {
    get {return _storage._revokedTime}
    set {_uniqueStorage()._revokedTime = newValue}
  }

  /// 附加信息
  var attachedInfo: String {
    get {return _storage._attachedInfo}
    set {_uniqueStorage()._attachedInfo = newValue}
  }

  /// 会话类型（1=单聊，2=群聊，3=聊天室，4=系统消息）
  var conversationType: Int32 {
    get {return _storage._conversationType}
    set {_uniqueStorage()._conversationType = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 发送消息请求
struct Im_Protocol_SendMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 复用通用消息结构
  var message: Im_Protocol_MessageInfo {
    get {return _message ?? Im_Protocol_MessageInfo()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Im_Protocol_MessageInfo? = nil
}

/// 发送消息响应
struct Im_Protocol_SendMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// ✅ 服务器消息 ID
  var serverMsgID: String = String()

  /// 客户端消息 ID（用于匹配本地消息）
  var clientMsgID: String = String()

  /// 消息序列号
  var seq: Int64 = 0

  /// 服务器时间
  var serverTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 推送消息
struct Im_Protocol_PushMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 复用通用消息结构
  var message: Im_Protocol_MessageInfo {
    get {return _message ?? Im_Protocol_MessageInfo()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Im_Protocol_MessageInfo? = nil
}

/// 消息 ACK
struct Im_Protocol_MessageAck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 服务器消息 ID
  var serverMsgID: String = String()

  var seq: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 批量消息
struct Im_Protocol_BatchMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Im_Protocol_PushMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 撤回消息请求
struct Im_Protocol_RevokeMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 服务器消息 ID
  var serverMsgID: String = String()

  var conversationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 撤回消息响应
struct Im_Protocol_RevokeMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 撤回消息推送
struct Im_Protocol_RevokeMessagePush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 服务器消息 ID
  var serverMsgID: String = String()

  var conversationID: String = String()

  var revokedBy: String = String()

  var revokedTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 会话同步状态（客户端本地状态）
struct Im_Protocol_ConversationSyncState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 会话ID
  var conversationID: String = String()

  /// 本地最大 seq
  var lastSeq: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 批量同步请求（一次性同步所有会话）
struct Im_Protocol_BatchSyncRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端的会话同步状态（可为空，表示首次全量同步）
  var conversationStates: [Im_Protocol_ConversationSyncState] = []

  /// 每个会话最多拉取的消息数（默认100，最大500）
  var maxCountPerConversation: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 会话消息结果
struct Im_Protocol_ConversationMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 会话ID
  var conversationID: String = String()

  /// 消息列表
  var messages: [Im_Protocol_MessageInfo] = []

  /// 服务端该会话的最大 seq
  var maxSeq: Int64 = 0

  /// 本次同步到的 seq（可能小于 max_seq，因为有 max_count 限制）
  var syncedSeq: Int64 = 0

  /// 是否还有更多消息未同步
  var hasMore_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 批量同步响应
struct Im_Protocol_BatchSyncResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 所有会话的消息
  var conversationMessages: [Im_Protocol_ConversationMessages] = []

  /// 服务器时间
  var serverTime: Int64 = 0

  /// 本次同步的总消息数
  var totalMessageCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 范围同步请求
struct Im_Protocol_SyncRangeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 请求唯一标识（由客户端生成，用于响应匹配）
  var requestID: String = String()

  /// 会话ID（必填）
  var conversationID: String = String()

  /// 起始 seq（包含）
  var startSeq: Int64 = 0

  /// 结束 seq（包含）
  var endSeq: Int64 = 0

  /// 单次拉取数量限制（默认100，最大500）
  var count: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 范围同步响应
struct Im_Protocol_SyncRangeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  /// 对应请求的 request_id
  var requestID: String = String()

  /// 会话ID
  var conversationID: String = String()

  /// 消息列表
  var messages: [Im_Protocol_MessageInfo] = []

  /// 实际返回的起始 seq
  var startSeq: Int64 = 0

  /// 实际返回的结束 seq
  var endSeq: Int64 = 0

  /// 是否还有更多消息（如果请求范围过大，需要分批拉取）
  var hasMore_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 已读回执请求
struct Im_Protocol_ReadReceiptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 服务器消息 ID 列表
  var serverMsgIds: [String] = []

  var conversationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 已读回执响应
struct Im_Protocol_ReadReceiptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Im_Protocol_ErrorCode = .errSuccess

  var errorMsg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 已读回执推送
struct Im_Protocol_ReadReceiptPush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ✅ 服务器消息 ID 列表
  var serverMsgIds: [String] = []

  var conversationID: String = String()

  var userID: String = String()

  var readTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 输入状态请求
struct Im_Protocol_TypingStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String = String()

  /// 0: 停止输入，1: 正在输入
  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 输入状态推送
struct Im_Protocol_TypingStatusPush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: String = String()

  var userID: String = String()

  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ============================================
/// WebSocket 专用消息封装
/// ============================================
///
/// WebSocket 传输使用此通用消息格式（不使用 IMPacket header）
/// WebSocket 自带消息边界和校验，无需额外的 length 和 CRC
struct Im_Protocol_WebSocketMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 命令类型
  var command: Im_Protocol_CommandType = .cmdUnknown

  /// 序列号
  var sequence: UInt32 = 0

  /// 消息体（具体消息的 Protobuf 序列化）
  var body: Data = Data()

  /// 时间戳（毫秒）
  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "im.protocol"

extension Im_Protocol_CommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CMD_UNKNOWN\0\u{1}CMD_CONNECT_REQ\0\u{1}CMD_CONNECT_RSP\0\u{1}CMD_DISCONNECT_REQ\0\u{1}CMD_DISCONNECT_RSP\0\u{1}CMD_HEARTBEAT_REQ\0\u{1}CMD_HEARTBEAT_RSP\0\u{2}^\u{1}CMD_AUTH_REQ\0\u{1}CMD_AUTH_RSP\0\u{1}CMD_REAUTH_REQ\0\u{1}CMD_REAUTH_RSP\0\u{1}CMD_KICK_OUT\0\u{2}`\u{1}CMD_SEND_MSG_REQ\0\u{1}CMD_SEND_MSG_RSP\0\u{1}CMD_PUSH_MSG\0\u{1}CMD_MSG_ACK\0\u{1}CMD_BATCH_MSG\0\u{1}CMD_REVOKE_MSG_REQ\0\u{1}CMD_REVOKE_MSG_RSP\0\u{1}CMD_REVOKE_MSG_PUSH\0\u{2}]\u{1}CMD_BATCH_SYNC_REQ\0\u{1}CMD_BATCH_SYNC_RSP\0\u{1}CMD_SYNC_FINISHED\0\u{1}CMD_SYNC_RANGE_REQ\0\u{1}CMD_SYNC_RANGE_RSP\0\u{2}`\u{1}CMD_ONLINE_STATUS_REQ\0\u{1}CMD_ONLINE_STATUS_RSP\0\u{1}CMD_STATUS_CHANGE_PUSH\0\u{2}b\u{1}CMD_READ_RECEIPT_REQ\0\u{1}CMD_READ_RECEIPT_RSP\0\u{1}CMD_READ_RECEIPT_PUSH\0\u{2}b\u{1}CMD_TYPING_STATUS_REQ\0\u{1}CMD_TYPING_STATUS_PUSH\0")
}

extension Im_Protocol_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ERR_SUCCESS\0\u{1}ERR_UNKNOWN\0\u{1}ERR_INVALID_PARAM\0\u{2}b\u{1}ERR_AUTH_FAILED\0\u{1}ERR_TOKEN_EXPIRED\0\u{1}ERR_PERMISSION_DENIED\0\u{1}ERR_USER_NOT_EXIST\0\u{2}a\u{1}ERR_MESSAGE_TOO_LARGE\0\u{1}ERR_SEND_TOO_FAST\0\u{1}ERR_CONVERSATION_NOT_EXIST\0")
}

extension Im_Protocol_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}client_id\0\u{1}platform\0\u{3}app_version\0\u{3}sdk_version\0\u{3}device_info\0\u{2}\u{5}extra\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deviceInfo) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extra) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 2)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 3)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 4)
    }
    if !self.deviceInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceInfo, fieldNumber: 5)
    }
    if !self.extra.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extra, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ConnectRequest, rhs: Im_Protocol_ConnectRequest) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs.deviceInfo != rhs.deviceInfo {return false}
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}server_time\0\u{3}session_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ConnectResponse, rhs: Im_Protocol_ConnectResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_HeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeartbeatRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}client_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientTime != 0 {
      try visitor.visitSingularInt64Field(value: self.clientTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_HeartbeatRequest, rhs: Im_Protocol_HeartbeatRequest) -> Bool {
    if lhs.clientTime != rhs.clientTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_HeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeartbeatResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_HeartbeatResponse, rhs: Im_Protocol_HeartbeatResponse) -> Bool {
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}token\0\u{1}platform\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_AuthRequest, rhs: Im_Protocol_AuthRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_AuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}max_seq\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if self.maxSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSeq, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_AuthResponse, rhs: Im_Protocol_AuthResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.maxSeq != rhs.maxSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_KickOutNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KickOutNotification"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != 0 {
      try visitor.visitSingularInt32Field(value: self.reason, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_KickOutNotification, rhs: Im_Protocol_KickOutNotification) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_MessageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_msg_id\0\u{3}client_msg_id\0\u{3}conversation_id\0\u{3}sender_id\0\u{3}receiver_id\0\u{3}group_id\0\u{3}message_type\0\u{1}content\0\u{3}send_time\0\u{3}server_time\0\u{1}seq\0\u{1}status\0\u{3}is_read\0\u{3}create_time\0\u{1}extra\0\u{3}read_by\0\u{3}read_time\0\u{3}is_deleted\0\u{3}is_revoked\0\u{3}revoked_by\0\u{3}revoked_time\0\u{3}attached_info\0\u{3}conversation_type\0")

  fileprivate class _StorageClass {
    var _serverMsgID: String = String()
    var _clientMsgID: String = String()
    var _conversationID: String = String()
    var _senderID: String = String()
    var _receiverID: String = String()
    var _groupID: String = String()
    var _messageType: Int32 = 0
    var _content: Data = Data()
    var _sendTime: Int64 = 0
    var _serverTime: Int64 = 0
    var _seq: Int64 = 0
    var _status: Int32 = 0
    var _isRead: Bool = false
    var _createTime: Int64 = 0
    var _extra: String = String()
    var _readBy: [String] = []
    var _readTime: Int64 = 0
    var _isDeleted: Bool = false
    var _isRevoked: Bool = false
    var _revokedBy: String = String()
    var _revokedTime: Int64 = 0
    var _attachedInfo: String = String()
    var _conversationType: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _serverMsgID = source._serverMsgID
      _clientMsgID = source._clientMsgID
      _conversationID = source._conversationID
      _senderID = source._senderID
      _receiverID = source._receiverID
      _groupID = source._groupID
      _messageType = source._messageType
      _content = source._content
      _sendTime = source._sendTime
      _serverTime = source._serverTime
      _seq = source._seq
      _status = source._status
      _isRead = source._isRead
      _createTime = source._createTime
      _extra = source._extra
      _readBy = source._readBy
      _readTime = source._readTime
      _isDeleted = source._isDeleted
      _isRevoked = source._isRevoked
      _revokedBy = source._revokedBy
      _revokedTime = source._revokedTime
      _attachedInfo = source._attachedInfo
      _conversationType = source._conversationType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._serverMsgID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._clientMsgID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._conversationID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._senderID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._receiverID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._groupID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._messageType) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._content) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._sendTime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._serverTime) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._seq) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isRead) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._extra) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._readBy) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._readTime) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._isDeleted) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._isRevoked) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._revokedBy) }()
        case 21: try { try decoder.decodeSingularInt64Field(value: &_storage._revokedTime) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._attachedInfo) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._conversationType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._serverMsgID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverMsgID, fieldNumber: 1)
      }
      if !_storage._clientMsgID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientMsgID, fieldNumber: 2)
      }
      if !_storage._conversationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._conversationID, fieldNumber: 3)
      }
      if !_storage._senderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderID, fieldNumber: 4)
      }
      if !_storage._receiverID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiverID, fieldNumber: 5)
      }
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 6)
      }
      if _storage._messageType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._messageType, fieldNumber: 7)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._content, fieldNumber: 8)
      }
      if _storage._sendTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sendTime, fieldNumber: 9)
      }
      if _storage._serverTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._serverTime, fieldNumber: 10)
      }
      if _storage._seq != 0 {
        try visitor.visitSingularInt64Field(value: _storage._seq, fieldNumber: 11)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 12)
      }
      if _storage._isRead != false {
        try visitor.visitSingularBoolField(value: _storage._isRead, fieldNumber: 13)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 14)
      }
      if !_storage._extra.isEmpty {
        try visitor.visitSingularStringField(value: _storage._extra, fieldNumber: 15)
      }
      if !_storage._readBy.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._readBy, fieldNumber: 16)
      }
      if _storage._readTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._readTime, fieldNumber: 17)
      }
      if _storage._isDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._isDeleted, fieldNumber: 18)
      }
      if _storage._isRevoked != false {
        try visitor.visitSingularBoolField(value: _storage._isRevoked, fieldNumber: 19)
      }
      if !_storage._revokedBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._revokedBy, fieldNumber: 20)
      }
      if _storage._revokedTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._revokedTime, fieldNumber: 21)
      }
      if !_storage._attachedInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attachedInfo, fieldNumber: 22)
      }
      if _storage._conversationType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._conversationType, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_MessageInfo, rhs: Im_Protocol_MessageInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serverMsgID != rhs_storage._serverMsgID {return false}
        if _storage._clientMsgID != rhs_storage._clientMsgID {return false}
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._senderID != rhs_storage._senderID {return false}
        if _storage._receiverID != rhs_storage._receiverID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._messageType != rhs_storage._messageType {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._sendTime != rhs_storage._sendTime {return false}
        if _storage._serverTime != rhs_storage._serverTime {return false}
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._isRead != rhs_storage._isRead {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._extra != rhs_storage._extra {return false}
        if _storage._readBy != rhs_storage._readBy {return false}
        if _storage._readTime != rhs_storage._readTime {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._isRevoked != rhs_storage._isRevoked {return false}
        if _storage._revokedBy != rhs_storage._revokedBy {return false}
        if _storage._revokedTime != rhs_storage._revokedTime {return false}
        if _storage._attachedInfo != rhs_storage._attachedInfo {return false}
        if _storage._conversationType != rhs_storage._conversationType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SendMessageRequest, rhs: Im_Protocol_SendMessageRequest) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}server_msg_id\0\u{3}client_msg_id\0\u{1}seq\0\u{3}server_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverMsgID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientMsgID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.seq) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.serverMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverMsgID, fieldNumber: 3)
    }
    if !self.clientMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientMsgID, fieldNumber: 4)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 5)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SendMessageResponse, rhs: Im_Protocol_SendMessageResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.serverMsgID != rhs.serverMsgID {return false}
    if lhs.clientMsgID != rhs.clientMsgID {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_PushMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_PushMessage, rhs: Im_Protocol_PushMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_MessageAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageAck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_msg_id\0\u{1}seq\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverMsgID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.seq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverMsgID, fieldNumber: 1)
    }
    if self.seq != 0 {
      try visitor.visitSingularInt64Field(value: self.seq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_MessageAck, rhs: Im_Protocol_MessageAck) -> Bool {
    if lhs.serverMsgID != rhs.serverMsgID {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_BatchMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchMessages"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messages\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_BatchMessages, rhs: Im_Protocol_BatchMessages) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_RevokeMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeMessageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_msg_id\0\u{3}conversation_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverMsgID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverMsgID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_RevokeMessageRequest, rhs: Im_Protocol_RevokeMessageRequest) -> Bool {
    if lhs.serverMsgID != rhs.serverMsgID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_RevokeMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_RevokeMessageResponse, rhs: Im_Protocol_RevokeMessageResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_RevokeMessagePush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeMessagePush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_msg_id\0\u{3}conversation_id\0\u{3}revoked_by\0\u{3}revoked_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverMsgID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.revokedBy) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.revokedTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverMsgID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverMsgID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.revokedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.revokedBy, fieldNumber: 3)
    }
    if self.revokedTime != 0 {
      try visitor.visitSingularInt64Field(value: self.revokedTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_RevokeMessagePush, rhs: Im_Protocol_RevokeMessagePush) -> Bool {
    if lhs.serverMsgID != rhs.serverMsgID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.revokedBy != rhs.revokedBy {return false}
    if lhs.revokedTime != rhs.revokedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ConversationSyncState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationSyncState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{3}last_seq\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if self.lastSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ConversationSyncState, rhs: Im_Protocol_ConversationSyncState) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.lastSeq != rhs.lastSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_BatchSyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchSyncRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_states\0\u{3}max_count_per_conversation\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conversationStates) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxCountPerConversation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversationStates, fieldNumber: 1)
    }
    if self.maxCountPerConversation != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCountPerConversation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_BatchSyncRequest, rhs: Im_Protocol_BatchSyncRequest) -> Bool {
    if lhs.conversationStates != rhs.conversationStates {return false}
    if lhs.maxCountPerConversation != rhs.maxCountPerConversation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ConversationMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationMessages"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{1}messages\0\u{3}max_seq\0\u{3}synced_seq\0\u{3}has_more\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxSeq) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.syncedSeq) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    if self.maxSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSeq, fieldNumber: 3)
    }
    if self.syncedSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.syncedSeq, fieldNumber: 4)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ConversationMessages, rhs: Im_Protocol_ConversationMessages) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.maxSeq != rhs.maxSeq {return false}
    if lhs.syncedSeq != rhs.syncedSeq {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_BatchSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchSyncResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}conversation_messages\0\u{3}server_time\0\u{3}total_message_count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.conversationMessages) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.serverTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalMessageCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.conversationMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversationMessages, fieldNumber: 3)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularInt64Field(value: self.serverTime, fieldNumber: 4)
    }
    if self.totalMessageCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalMessageCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_BatchSyncResponse, rhs: Im_Protocol_BatchSyncResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.conversationMessages != rhs.conversationMessages {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.totalMessageCount != rhs.totalMessageCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SyncRangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncRangeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}conversation_id\0\u{3}start_seq\0\u{3}end_seq\0\u{1}count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startSeq) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.endSeq) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.startSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.startSeq, fieldNumber: 3)
    }
    if self.endSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.endSeq, fieldNumber: 4)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SyncRangeRequest, rhs: Im_Protocol_SyncRangeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.startSeq != rhs.startSeq {return false}
    if lhs.endSeq != rhs.endSeq {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_SyncRangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncRangeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0\u{3}request_id\0\u{3}conversation_id\0\u{1}messages\0\u{3}start_seq\0\u{3}end_seq\0\u{3}has_more\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.startSeq) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.endSeq) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 4)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 5)
    }
    if self.startSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.startSeq, fieldNumber: 6)
    }
    if self.endSeq != 0 {
      try visitor.visitSingularInt64Field(value: self.endSeq, fieldNumber: 7)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_SyncRangeResponse, rhs: Im_Protocol_SyncRangeResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.startSeq != rhs.startSeq {return false}
    if lhs.endSeq != rhs.endSeq {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ReadReceiptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadReceiptRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_msg_ids\0\u{3}conversation_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.serverMsgIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverMsgIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serverMsgIds, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ReadReceiptRequest, rhs: Im_Protocol_ReadReceiptRequest) -> Bool {
    if lhs.serverMsgIds != rhs.serverMsgIds {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ReadReceiptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadReceiptResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}error_code\0\u{3}error_msg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .errSuccess {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMsg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ReadReceiptResponse, rhs: Im_Protocol_ReadReceiptResponse) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMsg != rhs.errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_ReadReceiptPush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadReceiptPush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_msg_ids\0\u{3}conversation_id\0\u{3}user_id\0\u{3}read_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.serverMsgIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.readTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverMsgIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serverMsgIds, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if self.readTime != 0 {
      try visitor.visitSingularInt64Field(value: self.readTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_ReadReceiptPush, rhs: Im_Protocol_ReadReceiptPush) -> Bool {
    if lhs.serverMsgIds != rhs.serverMsgIds {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.readTime != rhs.readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_TypingStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_TypingStatusRequest, rhs: Im_Protocol_TypingStatusRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_TypingStatusPush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingStatusPush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conversation_id\0\u{3}user_id\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_TypingStatusPush, rhs: Im_Protocol_TypingStatusPush) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Im_Protocol_WebSocketMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebSocketMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}sequence\0\u{1}body\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .cmdUnknown {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 2)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Im_Protocol_WebSocketMessage, rhs: Im_Protocol_WebSocketMessage) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.body != rhs.body {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
