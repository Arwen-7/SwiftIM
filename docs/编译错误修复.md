# 编译错误修复总结

## 🐛 问题 1: `Cannot find 'userID' in scope`

### 错误代码
```swift
guard message.senderID == userID else {
    return .failure(.permissionDenied)
}
```

### 原因
`IMMessageManager` 中没有 `userID` 属性，这个变量不存在。

### 修复方案
使用 `getCurrentUserID()` 方法获取当前用户 ID：

```swift
guard message.senderID == getCurrentUserID() else {
    return .failure(.permissionDenied)
}
```

---

## 🐛 问题 2: 协议方法签名不匹配

### 错误代码

**协议定义：**
```swift
func onMessageRevoked(_ messageID: String)  // ❌ 参数类型不匹配
```

**调用代码：**
```swift
listener.onMessageRevoked(message: message)  // 传递的是 IMMessage
```

### 原因
协议定义接受的是 `String` 类型的 `messageID`，但调用时传递的是 `IMMessage` 对象。

### 修复方案

#### 1. 修改协议定义

```swift
public protocol IMMessageListener: AnyObject {
    /// 消息被撤回
    /// - Parameter message: 被撤回的消息（已更新为撤回状态）
    func onMessageRevoked(message: IMMessage)
}

// 提供默认实现
public extension IMMessageListener {
    func onMessageRevoked(message: IMMessage) {}
}
```

**为什么传递 `IMMessage` 更好？**
- ✅ UI 层可以访问完整的消息信息（发送者、时间等）
- ✅ 可以区分"你撤回了一条消息"还是"对方撤回了一条消息"
- ✅ 更灵活，便于 UI 展示

---

## 🐛 问题 3: 重复的监听器定义

### 错误代码

```swift
// IMMessageManager+P0Features.swift
extension IMMessageListener {
    @objc optional func onMessageRevoked(message: IMMessage)  // ❌ 重复定义
}
```

### 原因
在 `IMMessageManager.swift` 中已经定义了完整的协议，不需要在扩展文件中重复定义。

### 修复方案
删除重复的定义，添加注释说明：

```swift
// MARK: - 监听器扩展
// 注意：监听器方法已在 IMMessageListener 协议中定义，并提供了默认空实现
```

---

## ✅ 修复后的完整代码

### IMMessageManager.swift

```swift
/// 消息监听器
public protocol IMMessageListener: AnyObject {
    /// 收到新消息
    func onMessageReceived(_ message: IMMessage)
    
    /// 消息状态改变
    func onMessageStatusChanged(_ message: IMMessage)
    
    /// 消息被撤回
    /// - Parameter message: 被撤回的消息（已更新为撤回状态）
    func onMessageRevoked(message: IMMessage)
    
    /// 消息已读回执
    func onMessageReadReceiptReceived(conversationID: String, messageIDs: [String])
}

// 提供默认实现，使所有方法可选
public extension IMMessageListener {
    func onMessageReceived(_ message: IMMessage) {}
    func onMessageStatusChanged(_ message: IMMessage) {}
    func onMessageRevoked(message: IMMessage) {}
    func onMessageReadReceiptReceived(conversationID: String, messageIDs: [String]) {}
}
```

### IMMessageManager+P0Features.swift

```swift
/// 撤回消息（同步方法）
@discardableResult
public func revokeMessage(messageID: String) -> Result<Void, IMError> {
    // 1. 从数据库获取消息
    guard let message = database.getMessage(messageID: messageID) else {
        return .failure(.messageNotFound)
    }
    
    // 2. 检查是否是发送者
    guard message.senderID == getCurrentUserID() else {
        return .failure(.permissionDenied)
    }
    
    // 3. 检查时间限制
    // ...
    
    // 4. 发送请求
    return sendRevokeRequest(messageID: messageID, conversationID: message.conversationID)
}

/// 处理撤回消息通知
internal func handleRevokeNotification(messageID: String, revokerID: String, revokeTime: Int64) {
    // 1. 更新数据库
    updateMessageAsRevoked(messageID: messageID, revokerID: revokerID, revokeTime: revokeTime)
    
    // 2. 获取消息
    guard let message = database.getMessage(messageID: messageID) else { return }
    
    // 3. 通知监听器
    notifyListeners { listener in
        listener.onMessageRevoked(message: message)  // ✅ 传递完整的消息对象
    }
    
    // 4. 更新会话
    updateConversationIfNeeded(message: message)
}
```

---

## 📊 UI 层使用示例

### 实现监听器

```swift
class ChatViewController: UIViewController, IMMessageListener {
    
    // ✅ 实现 onMessageRevoked 方法
    func onMessageRevoked(message: IMMessage) {
        // 可以访问完整的消息信息
        let isMine = message.senderID == getCurrentUserID()
        
        if isMine {
            // 我撤回的消息
            updateMessageCell(messageID: message.messageID, text: "你撤回了一条消息")
        } else {
            // 对方撤回的消息
            let senderName = getSenderName(message.senderID)
            updateMessageCell(messageID: message.messageID, text: "\(senderName) 撤回了一条消息")
        }
        
        // 播放动画
        animateMessageRevoke(messageID: message.messageID)
    }
    
    func onMessageReceived(_ message: IMMessage) {
        // 收到新消息
    }
    
    func onMessageStatusChanged(_ message: IMMessage) {
        // 消息状态改变
    }
    
    func onMessageReadReceiptReceived(conversationID: String, messageIDs: [String]) {
        // 已读回执
    }
}
```

### 发起撤回

```swift
func onRevokeButtonTapped(messageID: String) {
    // 同步方法，立即返回结果
    let result = IMClient.shared.messageManager?.revokeMessage(messageID: messageID)
    
    switch result {
    case .success:
        print("撤回请求已发送")
        // ⚠️ 不要在这里更新 UI
        // UI 更新在 onMessageRevoked 回调中处理
        
    case .failure(let error):
        showError("撤回失败: \(error)")
        
    case .none:
        showError("消息管理器未初始化")
    }
}
```

---

## 🎯 总结

### 修复清单

- ✅ 修复 `userID` 作用域问题 → 使用 `getCurrentUserID()`
- ✅ 修改协议方法签名 → `onMessageRevoked(message: IMMessage)`
- ✅ 删除重复的监听器定义
- ✅ 提供默认空实现，使所有方法可选

### 关键改进

1. **更好的 API 设计**
   - 传递完整的 `IMMessage` 对象
   - UI 层可以访问更多信息

2. **代码一致性**
   - 与其他监听器方法保持一致（都传递对象而非 ID）
   - 易于理解和使用

3. **灵活性**
   - UI 层可以根据消息信息做差异化展示
   - 便于后续扩展

---

## 💡 最佳实践

### 监听器方法设计原则

1. **传递完整对象 > 只传 ID**
   ```swift
   // ✅ 推荐：传递完整对象
   func onMessageRevoked(message: IMMessage)
   
   // ❌ 不推荐：只传 ID（信息不足）
   func onMessageRevoked(_ messageID: String)
   ```

2. **提供默认实现**
   ```swift
   public extension IMMessageListener {
       func onMessageRevoked(message: IMMessage) {}  // 默认空实现
   }
   ```

3. **清晰的文档注释**
   ```swift
   /// 消息被撤回
   /// - Parameter message: 被撤回的消息（已更新为撤回状态）
   func onMessageRevoked(message: IMMessage)
   ```

**编译错误已全部修复！** ✨

