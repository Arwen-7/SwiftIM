# 消息机制架构总结（已优化）

## 🎯 架构设计原则

### 清晰的职责分离

```
WebSocket = 实时推送 (Push)
HTTP = 主动拉取 (Pull)
```

---

## 📊 完整消息机制

### 1️⃣ WebSocket 推送机制（实时）

| 命令类型 | 用途 | 场景 |
|---------|------|------|
| **cmdPushMsg** | 推送单条消息 | 用户在线时收到新消息 |
| **cmdBatchMsg** | 推送批量消息 | 群聊消息、离线消息补推 |
| cmdRevokeMsgPush | 撤回消息推送 | 对方撤回了消息 |
| cmdReadReceiptPush | 已读回执推送 | 对方已读你的消息 |
| cmdTypingStatusPush | 输入状态推送 | 对方正在输入... |

**特点：**
- ✅ 实时性高（< 100ms）
- ✅ 服务器主动推送
- ✅ 适合在线场景
- ✅ 长连接，持续监听

---

### 2️⃣ HTTP 拉取机制（离线）

| 接口 | 用途 | 场景 |
|------|------|------|
| **GET /api/sync** | 增量同步 | 断线重连，拉取离线消息 |
| GET /api/messages/history | 历史消息 | 查看聊天记录 |
| GET /api/conversations | 会话列表 | 刷新会话 |

**特点：**
- ✅ 可控、可重试
- ✅ 客户端主动发起
- ✅ 适合批量拉取
- ✅ 可分页、可过滤

---

## 🔄 完整流程示例

### 场景 1：用户在线聊天（WebSocket Push）

```
用户 A：发送 "你好"
        ↓
服务器收到
        ↓
通过 WebSocket 推送给用户 B
        ↓
cmdPushMsg
        ↓
handleWebSocketPushMessage()
        ↓
messageManager.handleReceivedMessage()
        ↓
保存到数据库 + 通知 UI
        ↓
用户 B：立即看到消息 ✅（< 100ms）
```

### 场景 2：用户离线重连（HTTP Pull）

```
用户 B：断网 30 分钟（期间收到 50 条消息）
        ↓
重新连接 WiFi
        ↓
WebSocket 连接成功
        ↓
触发离线同步
        ↓
syncOfflineMessagesAfterReconnect()
        ↓
messageSyncManager.sync(fromSeq: 1000)
        ↓
HTTP GET /api/sync?lastSeq=1000&count=500
        ↓
服务器返回 50 条离线消息
        ↓
批量保存到数据库
        ↓
用户 B：看到 50 条未读消息 ✅
```

### 场景 3：群聊历史消息（WebSocket Push）

```
用户 B：加入新群聊
        ↓
服务器推送群历史消息（最近 100 条）
        ↓
通过 WebSocket 推送
        ↓
cmdBatchMsg
        ↓
handleWebSocketBatchMessages()
        ↓
逐条调用 messageManager.handleReceivedMessage()
        ↓
批量保存 + 通知 UI
        ↓
用户 B：看到群聊历史 ✅
```

---

## 🎨 代码结构

### WebSocket 消息路由

```swift
// IMClient.swift: routeWebSocketMessage()

switch wsMessage.command {
case .cmdPushMsg:
    // ✅ 单条消息推送
    handleWebSocketPushMessage(body, sequence)
    
case .cmdBatchMsg:
    // ✅ 批量消息推送
    handleWebSocketBatchMessages(body, sequence)
    
case .cmdAuthRsp:
    // ✅ 认证响应
    handleWebSocketAuthResponse(body, sequence)
    
case .cmdHeartbeatRsp:
    // ✅ 心跳响应
    handleWebSocketHeartbeatResponse(body, sequence)
    
case .cmdRevokeMsgPush:
    // ✅ 撤回消息推送
    handleWebSocketRevokeMessage(body, sequence)
    
case .cmdReadReceiptPush:
    // ✅ 已读回执推送
    handleWebSocketReadReceipt(body, sequence)
    
case .cmdTypingStatusPush:
    // ✅ 输入状态推送
    handleWebSocketTypingStatus(body, sequence)
    
case .cmdKickOut:
    // ✅ 踢出通知
    handleWebSocketKickOut(body)
    
// ❌ 已删除：cmdSyncRsp（冗余，由 HTTP 负责）
    
default:
    IMLogger.shared.warning("Unhandled command: \(wsMessage.command)")
}
```

### HTTP 同步流程

```swift
// IMClient.swift: syncOfflineMessagesAfterReconnect()

private func syncOfflineMessagesAfterReconnect() {
    let localMaxSeq = database.getMaxSeq()
    
    // 通过 HTTP 主动拉取
    messageSyncManager?.sync(fromSeq: localMaxSeq + 1) { result in
        switch result {
        case .success:
            IMLogger.shared.info("✅ Sync completed")
        case .failure(let error):
            IMLogger.shared.error("❌ Sync failed: \(error)")
        }
    }
}
```

---

## ✅ 优化总结

### 删除前（冗余）

```
WebSocket:
  - cmdPushMsg      ✅
  - cmdBatchMsg     ✅
  - cmdSyncRsp      ❌ 冗余！

HTTP:
  - GET /api/sync   ✅
```

**问题：**
- cmdSyncRsp 与 cmdBatchMsg 功能重叠
- WebSocket 不应该有 Sync 的概念
- 增加复杂度，混淆职责

### 删除后（清晰）

```
WebSocket:
  - cmdPushMsg      ✅ 单条推送
  - cmdBatchMsg     ✅ 批量推送

HTTP:
  - GET /api/sync   ✅ 离线同步
```

**优点：**
- ✅ 职责清晰：WebSocket = Push，HTTP = Pull
- ✅ 代码简洁：减少冗余逻辑
- ✅ 易于维护：开发者清楚何时用何种机制
- ✅ 符合标准：微信、钉钉都是这样做的

---

## 📋 消息处理统一入口

### 所有消息最终都调用

```swift
messageManager?.handleReceivedMessage(message)
```

**这个方法负责：**
1. 消息去重（通过 messageID）
2. 保存到数据库
3. 更新会话列表
4. 通知监听器（刷新 UI）

**无论消息来自：**
- WebSocket 单条推送（cmdPushMsg）
- WebSocket 批量推送（cmdBatchMsg）
- HTTP 离线同步（sync API）

**都使用相同的处理逻辑！** ✨

---

## 🚀 性能优化

### WebSocket 推送（实时性优先）

- 单条消息：立即处理
- 批量消息：逐条处理（避免阻塞）
- 异步保存：不阻塞 UI

### HTTP 拉取（可靠性优先）

- 分页加载：每次 500 条
- 失败重试：最多 3 次
- 后台处理：不阻塞主线程

---

## 🎯 最佳实践

### 何时使用 WebSocket Push？

- ✅ 用户在线时的即时消息
- ✅ 实时状态更新（输入状态、在线状态）
- ✅ 系统通知（踢出、撤回）

### 何时使用 HTTP Pull？

- ✅ 离线消息同步
- ✅ 历史消息查询
- ✅ 用户主动刷新

### 混合使用策略

```
用户在线
    ↓
优先使用 WebSocket Push（实时性高）
    ↓
WebSocket 断开/不稳定
    ↓
回退到 HTTP Pull（可靠性高）
    ↓
WebSocket 重连成功
    ↓
HTTP Pull 补偿漏掉的消息
    ↓
恢复 WebSocket Push
```

---

## 📊 对比表格

| 维度 | WebSocket Push | HTTP Pull |
|------|---------------|-----------|
| **实时性** | ⭐⭐⭐⭐⭐ 极高 | ⭐⭐⭐ 中等 |
| **可靠性** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 极高 |
| **流量消耗** | ⭐⭐⭐⭐⭐ 低 | ⭐⭐⭐ 中等 |
| **服务器压力** | ⭐⭐⭐ 中等 | ⭐⭐ 较高 |
| **适用场景** | 在线即时通讯 | 离线消息同步 |
| **重试策略** | ⭐⭐ 有限 | ⭐⭐⭐⭐⭐ 完善 |
| **批量处理** | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 优秀 |

---

## 💡 总结

### 核心原则

```
简单即是美
职责要清晰
Push + Pull = 完美
```

### 架构优势

1. **职责分离**：WebSocket 专注推送，HTTP 专注拉取
2. **互补增强**：实时性 + 可靠性 = 最佳体验
3. **易于维护**：代码简洁，逻辑清晰
4. **符合标准**：业界最佳实践

### 用户体验

- ✅ 在线聊天：< 100ms 延迟
- ✅ 离线重连：可靠不丢消息
- ✅ 弱网环境：自动降级到 HTTP
- ✅ 消息可靠：去重、重试、补偿

**简洁、高效、可靠的消息机制！** 🎉

