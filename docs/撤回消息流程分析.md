# 撤回消息流程分析

## 🤔 问题

当前的 `revokeMessage` 实现存在严重的架构问题！

### ❌ 错误的实现方式

```swift
public func revokeMessage(messageID: String, completion: @escaping (Result<Void, IMError>) -> Void) {
    // 1. 发送撤回请求到服务器
    sendRevokeRequest(request) { result in
        switch result {
        case .success:
            // ❌ 错误：收到 HTTP/WebSocket 响应后直接更新数据库
            self.updateMessageAsRevoked(...)
            self.notifyListeners { listener in
                listener.onMessageRevoked?(message: message)
            }
            completion(.success(()))
        case .failure(let error):
            completion(.failure(error))
        }
    }
}
```

### 问题分析

| 问题 | 描述 | 影响 |
|------|------|------|
| **状态更新方式不一致** | 发送者通过 HTTP 响应更新，接收者通过 WebSocket 推送更新 | 🔴 状态不一致风险 |
| **重复处理** | 发送者会收到两次更新（HTTP 响应 + WebSocket 推送） | 🔴 需要去重逻辑 |
| **时序问题** | HTTP 响应可能比 WebSocket 推送慢 | 🔴 状态可能被覆盖 |
| **异步等待** | 需要等待服务器响应才更新 UI | 🟡 用户体验差 |

---

## ✅ 正确的 IM 架构

### 核心原则

```
所有状态变更都应该通过 WebSocket 推送来触发！
```

### 正确的流程

```
用户 A 点击"撤回"
        ↓
IMMessageManager.revokeMessage()
        ↓
发送撤回请求到服务器（立即返回）✅
        ↓
        ├─ 返回 .success（表示请求已发送）
        │  ↓
        │  UI 可以显示"撤回中..."（可选）
        │
        ↓ (服务器处理)
        │
服务器处理撤回请求
        ↓
服务器验证权限、时间等
        ↓
服务器标记消息为已撤回
        ↓
服务器通过 WebSocket 推送撤回通知给所有相关用户
        ↓
        ├─ 推送给用户 A（发送者）
        │  ↓
        │  handleRevokeNotification()
        │  ↓
        │  更新数据库 + 通知 UI ✅
        │
        └─ 推送给用户 B（接收者）
           ↓
           handleRevokeNotification()
           ↓
           更新数据库 + 通知 UI ✅
```

### 优势

| 优势 | 说明 |
|------|------|
| ✅ **状态一致** | 所有用户都通过同一个 WebSocket 推送更新，保证状态一致 |
| ✅ **代码简洁** | 只有一个更新数据库的地方（handleRevokeNotification） |
| ✅ **实时性高** | WebSocket 推送比 HTTP 轮询快 |
| ✅ **易于调试** | 所有用户的更新路径相同 |
| ✅ **符合 IM 标准** | 微信、钉钉等都是这样做的 |

---

## 🔧 修复方案

### 1. 修改 `revokeMessage` 方法

```swift
/// 撤回消息（同步方法）
/// - Parameters:
///   - messageID: 消息 ID
///   - completion: 完成回调（立即返回，只表示请求是否发送成功）
/// - Note: 实际的撤回结果会通过 WebSocket 推送通知（handleRevokeNotification）
public func revokeMessage(
    messageID: String,
    completion: @escaping (Result<Void, IMError>) -> Void
) {
    // 1. 从数据库获取消息
    guard let message = database.getMessage(messageID: messageID) else {
        completion(.failure(.messageNotFound))
        return
    }
    
    // 2. 检查是否是发送者
    guard message.senderID == getCurrentUserID() else {
        completion(.failure(.permissionDenied))
        return
    }
    
    // 3. 检查时间限制（2 分钟内）
    let currentTime = Int64(Date().timeIntervalSince1970 * 1000)
    let elapsed = currentTime - message.sendTime
    let revokeTimeLimit: Int64 = 2 * 60 * 1000  // 2 分钟
    
    guard elapsed <= revokeTimeLimit else {
        completion(.failure(.revokeTimeExpired))
        return
    }
    
    // 4. 构建并发送撤回请求到服务器
    let request = IMRevokeMessageRequest(
        messageID: messageID,
        conversationID: message.conversationID
    )
    
    // 5. 发送请求（立即返回，不等待结果）
    sendRevokeRequest(request) { result in
        switch result {
        case .success:
            // ✅ 只返回请求发送成功，不更新数据库
            // 实际的数据库更新会在收到 WebSocket 推送时进行（handleRevokeNotification）
            completion(.success(()))
            
        case .failure(let error):
            // ❌ 请求发送失败
            completion(.failure(error))
        }
    }
    
    // ⚠️ 注意：此时消息还未真正撤回！
    // 真正的撤回会在收到服务器的 WebSocket 推送后完成
}
```

### 2. 服务器推送处理（已有）

```swift
// IMClient.swift
private func handleWebSocketRevokeMessage(_ body: Data, sequence: UInt32) {
    let revokeMsg = try Im_Protocol_RevokeMessagePush(serializedData: body)
    
    // ✅ 所有用户（包括发送者）都通过这里更新
    messageManager?.handleRevokeNotification(
        messageID: revokeMsg.messageID,
        revokerID: revokeMsg.revokedBy,
        revokeTime: revokeMsg.revokedTime
    )
}

// IMMessageManager+P0Features.swift
internal func handleRevokeNotification(messageID: String, revokerID: String, revokeTime: Int64) {
    // 1. 更新数据库
    updateMessageAsRevoked(messageID: messageID, revokerID: revokerID, revokeTime: revokeTime)
    
    // 2. 获取消息
    guard let message = database.getMessage(messageID: messageID) else { return }
    
    // 3. 通知监听器（UI 刷新）
    notifyListeners { listener in
        listener.onMessageRevoked?(message: message)
    }
    
    // 4. 更新会话
    updateConversationIfNeeded(message: message)
}
```

---

## 📊 对比

### ❌ 错误方式（修改前）

```
用户 A 撤回消息
        ↓
发送请求到服务器
        ↓
等待服务器响应 (100-500ms)
        ↓
收到响应后更新数据库 ❌
        ↓
通知 UI 刷新
        ↓
（稍后）收到 WebSocket 推送 ❌
        ↓
再次更新数据库？去重？混乱！❌
```

**问题：**
- 🔴 双重更新（HTTP 响应 + WebSocket 推送）
- 🔴 需要复杂的去重逻辑
- 🔴 发送者和接收者的更新路径不同
- 🔴 可能的时序问题

### ✅ 正确方式（修改后）

```
用户 A 撤回消息
        ↓
发送请求到服务器（立即返回）✅
        ↓
UI 显示"发送中"（可选）
        ↓
（等待服务器处理...）
        ↓
收到 WebSocket 推送 ✅
        ↓
更新数据库（唯一入口）✅
        ↓
通知 UI 刷新
```

**优点：**
- ✅ 单一更新路径
- ✅ 发送者和接收者逻辑一致
- ✅ 不需要去重
- ✅ 代码简洁

---

## 🎨 UI 层最佳实践

### 用户体验优化

```swift
// UI 层代码示例
class ChatViewController {
    func onRevokeButtonTapped(messageID: String) {
        // 1. 立即显示"撤回中"状态（乐观更新）
        updateMessageUI(messageID: messageID, status: .revoking)
        
        // 2. 发送撤回请求
        IMClient.shared.messageManager?.revokeMessage(messageID: messageID) { result in
            switch result {
            case .success:
                // ✅ 请求发送成功，等待 WebSocket 推送
                print("撤回请求已发送，等待服务器确认...")
                // 不更新 UI！等待 onMessageRevoked 回调
                
            case .failure(let error):
                // ❌ 请求发送失败，恢复原状态
                self.updateMessageUI(messageID: messageID, status: .normal)
                self.showError("撤回失败: \(error)")
            }
        }
    }
}

// IMMessageListener
extension ChatViewController: IMMessageListener {
    func onMessageRevoked(message: IMMessage) {
        // ✅ 收到 WebSocket 推送后的真正更新
        updateMessageUI(messageID: message.messageID, status: .revoked)
        showToast("消息已撤回")
    }
}
```

---

## 🚀 类比：发送消息的流程

撤回消息的流程应该和**发送消息**的流程一致！

### 发送消息

```
用户发送消息
    ↓
IMMessageManager.sendMessage()
    ↓
消息加入发送队列（状态：sending）✅
    ↓
立即返回 .success（表示已加入队列）✅
    ↓
（后台发送到服务器...）
    ↓
收到服务器 ACK
    ↓
更新消息状态为 .sent ✅
```

### 撤回消息（应该类似）

```
用户撤回消息
    ↓
IMMessageManager.revokeMessage()
    ↓
发送撤回请求到服务器 ✅
    ↓
立即返回 .success（表示请求已发送）✅
    ↓
（等待服务器处理...）
    ↓
收到 WebSocket 推送
    ↓
更新消息状态为 .revoked ✅
```

**一致性原则：** 所有状态变更都通过推送来触发！

---

## 💡 总结

### 核心设计原则

1. **请求发送 ≠ 操作完成**
   - `revokeMessage` 返回成功 = 请求已发送
   - 真正撤回成功 = 收到 WebSocket 推送

2. **统一的状态更新路径**
   - 所有用户都通过 `handleRevokeNotification` 更新
   - 避免多路径导致的不一致

3. **实时性与一致性**
   - WebSocket 推送保证所有用户同步
   - 不依赖 HTTP 响应更新状态

### 修改清单

- ✅ 修改 `revokeMessage` 方法，移除内部的数据库更新逻辑
- ✅ 修改注释，明确说明流程
- ✅ 保留 `handleRevokeNotification`，作为唯一的数据库更新入口

**这样的设计才是正确的 IM 架构！** 🎉

