# 消息撤回架构优化

## 🐛 问题描述

**编译错误：**
```
Value of type 'IMMessageManager' has no member 'handleMessageRevoked'
```

**出现位置：**
1. `IMClient.handleWebSocketRevokeMessage()`
2. `IMClient.handleTCPRevokeMessagePush()`

---

## 🔍 问题分析

### 原因

`IMMessageManager` 中实际存在的方法是 `handleRevokeNotification`，但它的签名是：

```swift
// ❌ 错误的假设
func handleRevokeNotification(_ notification: IMRevokeMessageNotification)

// ✅ 实际上 IMRevokeMessageNotification 类型不存在
```

### 架构问题

1. **类型缺失**：`IMRevokeMessageNotification` 类型不存在（已被 Protobuf 替代）
2. **职责混乱**：`IMClient` 直接操作数据库，然后再通知 `IMMessageManager`
3. **重复逻辑**：数据库更新逻辑在两处重复

---

## ✅ 解决方案

### 1. 简化方法签名

**修改前：**
```swift
// IMMessageManager+P0Features.swift
internal func handleRevokeNotification(_ notification: IMRevokeMessageNotification) {
    updateMessageAsRevoked(
        messageID: notification.messageID,
        revokerID: notification.revokerID,
        revokeTime: notification.revokeTime
    )
    // ...
}
```

**修改后：**
```swift
// IMMessageManager+P0Features.swift
/// 处理撤回消息通知（来自 WebSocket/TCP 推送）
/// - Parameters:
///   - messageID: 消息 ID
///   - revokerID: 撤回者 ID
///   - revokeTime: 撤回时间（毫秒时间戳）
internal func handleRevokeNotification(messageID: String, revokerID: String, revokeTime: Int64) {
    // 1. 更新本地数据库
    updateMessageAsRevoked(
        messageID: messageID,
        revokerID: revokerID,
        revokeTime: revokeTime
    )
    
    // 2. 获取更新后的消息
    guard let message = database.getMessage(messageID: messageID) else {
        return
    }
    
    // 3. 通知监听者
    notifyListeners { listener in
        listener.onMessageRevoked?(message: message)
    }
    
    // 4. 更新会话最后一条消息（如果是最后一条）
    updateConversationIfNeeded(message: message)
    
    IMLogger.shared.info("Message revoked: \(messageID) by \(revokerID)")
}
```

**优点：**
- ✅ 不依赖不存在的类型
- ✅ 直接接受 Protobuf 解析出的参数
- ✅ 方法签名简洁明了

---

### 2. 统一调用方式（WebSocket）

**修改前：**
```swift
// IMClient.swift: handleWebSocketRevokeMessage()
IMLogger.shared.info("Received revoke message: id=\(revokeMsg.messageID)")

// ❌ IMClient 直接操作数据库
do {
    try databaseManager?.revokeMessage(
        messageID: revokeMsg.messageID,
        revokerID: revokeMsg.revokedBy,
        revokeTime: revokeMsg.revokedTime
    )
    
    // ❌ 然后再调用不存在的方法
    if let message = databaseManager?.getMessage(messageID: revokeMsg.messageID) {
        messageManager?.handleMessageRevoked(message)
    }
} catch {
    IMLogger.shared.error("Failed to handle revoke message: \(error)")
}
```

**修改后：**
```swift
// IMClient.swift: handleWebSocketRevokeMessage()
IMLogger.shared.info("Received revoke message: id=\(revokeMsg.messageID)")

// ✅ 直接委托给 messageManager 处理（会自动更新数据库、通知监听器）
messageManager?.handleRevokeNotification(
    messageID: revokeMsg.messageID,
    revokerID: revokeMsg.revokedBy,
    revokeTime: revokeMsg.revokedTime
)
```

**优点：**
- ✅ 职责清晰：`IMClient` 只负责路由，`IMMessageManager` 负责业务逻辑
- ✅ 代码简洁：从 13 行减少到 4 行
- ✅ 易于维护：逻辑集中在一处

---

### 3. 统一调用方式（TCP）

**修改前：**
```swift
// IMClient.swift: handleTCPRevokeMessagePush()
private func handleTCPRevokeMessagePush(_ push: Im_Protocol_RevokeMessagePush) {
    do {
        // ❌ 直接操作数据库
        try databaseManager?.revokeMessage(
            messageID: push.messageID,
            revokerID: push.revokedBy,
            revokeTime: push.revokedTime
        )
        
        // ❌ 调用不存在的方法
        if let message = databaseManager?.getMessage(messageID: push.messageID) {
            messageManager?.handleMessageRevoked(message)
        }
    } catch {
        IMLogger.shared.error("Failed to handle TCP revoke message: \(error)")
    }
}
```

**修改后：**
```swift
// IMClient.swift: handleTCPRevokeMessagePush()
private func handleTCPRevokeMessagePush(_ push: Im_Protocol_RevokeMessagePush) {
    // ✅ 调用消息管理器处理撤回（会自动更新数据库、通知监听器）
    messageManager?.handleRevokeNotification(
        messageID: push.messageID,
        revokerID: push.revokedBy,
        revokeTime: push.revokedTime
    )
}
```

**优点：**
- ✅ 与 WebSocket 保持一致
- ✅ 代码从 14 行减少到 6 行
- ✅ 移除了重复的错误处理逻辑

---

## 📊 架构对比

### ❌ 修改前（职责混乱）

```
┌─────────────────────────────────────────┐
│ IMClient.handleWebSocketRevokeMessage   │
│                                          │
│ 1. 解析 Protobuf                         │
│ 2. ❌ 直接操作 databaseManager          │
│ 3. ❌ 直接获取 message                  │
│ 4. ❌ 调用不存在的方法                  │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│ IMMessageManager.handleMessageRevoked   │
│ ❌ 方法不存在！                          │
└─────────────────────────────────────────┘
```

### ✅ 修改后（职责清晰）

```
┌─────────────────────────────────────────┐
│ IMClient.handleWebSocketRevokeMessage   │
│                                          │
│ 1. 解析 Protobuf                         │
│ 2. ✅ 委托给 messageManager             │
└─────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────┐
│ IMMessageManager.handleRevokeNotification│
│                                          │
│ 1. ✅ 更新数据库                         │
│ 2. ✅ 获取消息                           │
│ 3. ✅ 通知监听器                         │
│ 4. ✅ 更新会话                           │
└─────────────────────────────────────────┘
```

---

## 🎯 架构原则

### 1. 单一职责原则（SRP）

| 组件 | 职责 |
|------|------|
| **IMClient** | 网络消息路由（解析 Protobuf，分发到业务层） |
| **IMMessageManager** | 消息业务逻辑（数据库操作、状态管理、通知） |
| **IMDatabaseManager** | 数据持久化（CRUD 操作） |

### 2. 依赖倒置原则（DIP）

- `IMClient` 不直接依赖 `IMDatabaseManager`
- 所有业务逻辑通过 `IMMessageManager` 处理
- 数据库操作封装在业务层内部

### 3. 接口隔离原则（ISP）

- `handleRevokeNotification` 接受简单参数
- 不依赖复杂的对象类型
- 易于测试和模拟

---

## 📝 代码统计

### WebSocket 处理

| 维度 | 修改前 | 修改后 | 改进 |
|------|--------|--------|------|
| 代码行数 | 13 行 | 4 行 | ✅ -69% |
| 数据库调用 | 2 次 | 0 次 | ✅ 封装在内部 |
| 错误处理 | 显式 try-catch | 自动处理 | ✅ 简化 |

### TCP 处理

| 维度 | 修改前 | 修改后 | 改进 |
|------|--------|--------|------|
| 代码行数 | 14 行 | 6 行 | ✅ -57% |
| 数据库调用 | 2 次 | 0 次 | ✅ 封装在内部 |
| 错误处理 | 显式 try-catch | 自动处理 | ✅ 简化 |

---

## ✅ 优化总结

### 主要改进

1. **修复编译错误**
   - ✅ 方法名从 `handleMessageRevoked` 改为 `handleRevokeNotification`
   - ✅ 参数从不存在的对象改为简单参数

2. **架构优化**
   - ✅ `IMClient` 不再直接操作数据库
   - ✅ 职责更加清晰（网络层 vs 业务层）
   - ✅ 代码更加简洁（减少 63% 代码）

3. **统一处理方式**
   - ✅ WebSocket 和 TCP 使用相同的处理逻辑
   - ✅ 易于维护和扩展

### 核心原则

```
IMClient: 路由消息
    ↓
IMMessageManager: 处理业务逻辑
    ↓
IMDatabaseManager: 持久化数据
```

**每一层只关注自己的职责，不越界操作！**

---

## 🚀 扩展性

### 未来添加新功能时

**示例：消息编辑功能**

```swift
// 1. 在 IMClient 中添加路由
case .cmdEditMsgPush:
    handleWebSocketEditMessage(wsMessage.body, sequence: wsMessage.sequence)

// 2. 在 IMClient 中添加处理方法
private func handleWebSocketEditMessage(_ body: Data, sequence: UInt32) {
    let editMsg = try Im_Protocol_EditMessagePush(serializedData: body)
    
    // ✅ 直接委托给 messageManager
    messageManager?.handleEditNotification(
        messageID: editMsg.messageID,
        newContent: editMsg.newContent,
        editTime: editMsg.editTime
    )
}

// 3. 在 IMMessageManager 中添加业务逻辑
internal func handleEditNotification(messageID: String, newContent: String, editTime: Int64) {
    // 1. 更新数据库
    // 2. 获取消息
    // 3. 通知监听器
    // 4. 更新会话
}
```

**优点：**
- ✅ 遵循现有模式
- ✅ 职责清晰
- ✅ 易于测试

---

## 💡 最佳实践

### ✅ 应该这样做

1. **网络层（IMClient）**：只负责解析 Protobuf 和路由
2. **业务层（IMMessageManager）**：处理所有业务逻辑和数据库操作
3. **数据层（IMDatabaseManager）**：纯粹的 CRUD 操作

### ❌ 不应该这样做

1. ❌ 在 `IMClient` 中直接操作数据库
2. ❌ 在 `IMClient` 中处理业务逻辑
3. ❌ 跨层调用（网络层直接调用数据层）

### 记住

> "让每一层只做自己应该做的事情，架构才会清晰优雅！"

---

## 📖 相关文档

- `IMProtocol.proto` - Protobuf 消息定义
- `IMMessageManager+P0Features.swift` - 消息撤回和已读回执功能
- `IMClient.swift` - 网络消息路由

**修复完成！架构更加清晰、简洁、易维护！** ✨

